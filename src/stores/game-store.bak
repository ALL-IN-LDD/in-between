import { defineStore } from 'pinia'
import { createDeck } from '@/utils/createDeck'
import { shuffle } from '@/utils/shuffleDeck'
import { cards } from '@/utils/data/cards'
import { reactive } from 'vue' // import reactive
import type { GameState } from '@/interface/card'

export const useGameStore = defineStore('game', {
  state: (): GameState => ({
    deck: [],
    faceUpCards: reactive([]), // Make faceUpCards reactive
    currentCard: null,
    pot: 500,
    currentBet: 0,
    message: '',
    gameOver: false,
    equalCardsChoice: null,
    awaitingEqualChoice: false,
  }),

  actions: {
    // Helper function to get card ID based on rank and suit
    getCardId(suit: string, rank: string): string {
      const card = cards.find((card) => card.suit === suit && card.rank === rank)
      return card ? card.id : ''
    },

    // Helper to ensure cards have proper ID
    ensureCardHasId(card: any) {
      if (card && !card.id && card.suit && card.rank) {
        card.id = this.getCardId(card.suit, card.rank)
      }
      return card
    },

    // Starts or restarts the game
    startGame() {
      // Create and shuffle the deck
      const createdDeck = createDeck()
      console.log('Created Deck:', createdDeck) // Debug log

      this.deck = shuffle(createdDeck)
      console.log('Shuffled Deck Length:', this.deck.length) // Debug log

      // Check if deck has enough cards
      if (this.deck.length < 2) {
        console.error('Deck has insufficient cards to start the game')
        this.message = 'Error initializing deck. Please refresh.'
        return
      }

      // Draw initial cards and ensure they have IDs
      try {
        const card1 = this.deck.pop()
        const card2 = this.deck.pop()

        console.log('Drawn Cards:', card1, card2) // Debug log

        if (!card1 || !card2) {
          throw new Error('Failed to draw cards from deck')
        }

        const cardWithId1 = this.ensureCardHasId(card1)
        const cardWithId2 = this.ensureCardHasId(card2)

        console.log('Cards with IDs:', cardWithId1, cardWithId2) // Debug log

        this.faceUpCards = [cardWithId1, cardWithId2] // Set faceUpCards here
        console.log('Face Up Cards after assignment:', this.faceUpCards) // Debug log
      } catch (error) {
        console.error('Error drawing initial cards:', error)
        this.message = 'Error drawing cards. Please restart.'
        return
      }

      // Initialize game state
      this.currentCard = null
      this.pot = 500
      this.currentBet = 0
      this.message = 'Game started! Place your bet.'
      this.gameOver = false
      this.equalCardsChoice = null
      this.awaitingEqualChoice = false
    },

    // Handles when player makes a bet
    placeBet(betAmount: number) {
      if (betAmount > this.pot) {
        this.message = 'Bet exceeds the pot amount!'
        return
      }

      this.currentBet = betAmount
      this.message = `Bet placed: ${betAmount}`
    },

    // Handles player's choice when face-up cards are equal
    handleEqualCardsChoice(choice: 'higher' | 'lower') {
      this.equalCardsChoice = choice
      this.awaitingEqualChoice = false
      this.drawThirdCard()
    },

    // Draws third card and determines win/loss
    drawThirdCard() {
      // Check if player made a bet
      if (this.currentBet <= 0) {
        this.message = 'Please place a bet first!'
        return
      }

      // Get the third card and ensure it has an ID
      const drawnCard = this.deck.pop()!
      this.currentCard = this.ensureCardHasId(drawnCard)

      // Card values for comparison (1=Ace through 13=King)
      const rankOrder: Record<string, number> = {
        '1': 1,
        '2': 2,
        '3': 3,
        '4': 4,
        '5': 5,
        '6': 6,
        '7': 7,
        '8': 8,
        '9': 9,
        '10': 10,
        jack: 11,
        queen: 12,
        king: 13,
      }

      // Convert cards to number values for easier comparison
      const card1 = this.faceUpCards[0]
      const card2 = this.faceUpCards[1]
      const r1 = card1?.rank ? rankOrder[card1.rank] : 0
      const r2 = card2?.rank ? rankOrder[card2.rank] : 0
      const r3 = this.currentCard?.rank ? rankOrder[this.currentCard.rank] : 0

      // Find which face-up card is higher/lower
      const lower = Math.min(r1, r2)
      const higher = Math.max(r1, r2)

      // If face-up cards are equal
      if (r1 === r2) {
        // If we're waiting for player's choice
        if (!this.equalCardsChoice && !this.awaitingEqualChoice) {
          this.awaitingEqualChoice = true
          this.message = 'Cards are equal! Choose to play higher or lower.'
          this.currentCard = null // Hide the drawn card until choice is made
          return
        }

        // Process the player's choice
        if (this.equalCardsChoice === 'higher') {
          if (r3 > r1) {
            this.pot -= this.currentBet * 2 // Double win for correct higher/lower
            this.message = `Win! ${this.currentCard?.rank} is higher than ${card1?.rank}.`
          } else {
            this.pot += this.currentBet
            this.message = `Lose! ${this.currentCard?.rank} is not higher than ${card1?.rank}.`
          }
        } else if (this.equalCardsChoice === 'lower') {
          if (r3 < r1) {
            this.pot -= this.currentBet * 2 // Double win for correct higher/lower
            this.message = `Win! ${this.currentCard?.rank} is lower than ${card1?.rank}.`
          } else {
            this.pot += this.currentBet
            this.message = `Lose! ${this.currentCard?.rank} is not lower than ${card1?.rank}.`
          }
        }

        // Reset the choice for next round
        this.equalCardsChoice = null
      }

      // If face-up cards are consecutive numbers
      else if (higher - lower === 1) {
        this.pot += this.currentBet
        this.message = 'Cards are consecutive. You lose your bet.'
      }

      // Otherwise, check if third card is between
      else {
        if (r3 > lower && r3 < higher) {
          this.pot -= this.currentBet
          this.message = `Win! ${this.currentCard?.rank} is between ${card1?.rank} and ${card2?.rank}.`
        } else if (r3 === r1 || r3 === r2) {
          // If it exactly matches (a "post") lose double bet.
          this.pot += this.currentBet * 2
          this.message = 'Card matches one of the face up cards. You lose double your bet!'
        } else {
          this.pot += this.currentBet
          this.message = `Lose. ${this.currentCard?.rank} is not between ${card1?.rank} and ${card2?.rank}.`
        }

        // Reset awaiting choice state when starting new round
        this.awaitingEqualChoice = false
      }

      // Prepare for next round or end game if deck is low
      if (this.deck.length < 3) {
        this.message += ' Not enough cards to continue. Game over.'
        this.gameOver = true
      } else {
        // Start a new round if game is still active.
        if (!this.gameOver) {
          const newCard1 = this.deck.pop()!
          const newCard2 = this.deck.pop()!
          this.faceUpCards = [this.ensureCardHasId(newCard1), this.ensureCardHasId(newCard2)]
          this.currentCard = null
          this.currentBet = 0
        }
      }
    },
  },
})
